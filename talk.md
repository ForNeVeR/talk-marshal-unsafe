На стыке управляемого и неуправляемого миров
============================================

.NET считается «управляемой» платформой — это означает, что код выполняется в
виртуальной машине, которая должна следить за соблюдением некоторых правил
(корректность адресов объектов, к которым обращается программа, отсутствие
выхода за пределы массивов). На такой платформе программисту живётся очень
удобно — ровно до тех пор, пока ему не приходится начать интеропиться с кодом,
написанным вне платформы. Сейчас, с распространением .NET (Core) на новые
платформы, это становится ещё более важным — потому для новых платформ ещё не
написано такого большого количества managed-библиотек, и поэтому частенько
приходится делать свои обёртки для нативного кода.

К счастью, .NET обладает богатым инструментарием, который позволяет практически
прозрачно общаться с нативным кодом. Этот доклад познакомит вас с основными
техниками вызова нативных функций из .NET-приложений, особенностями размещения в
памяти структур, которыми может обмениваться управляемый и неуправляемый код, а
также некоторыми подводными камнями, которые обязательно оказываются на пути у
тех, кто начинает работу с нативным кодом из .NET.

В данном докладе я постараюсь говорить обо всех современных реализациях .NET: о
.NET Framework, Mono и .NET Core.

## Способы взаимодействия управляемого и неуправляемого кода

Представим, что мы пишем программу на C#, и вдруг появляется нативная
библиотека, с которой мы хотим поработать. В общем в .NET-платформе есть
несколько основных способов, как нам позвать нативный код:

- это C++/CLI — вариант языка C++, который компилируется в байт-код виртуальной
  машины .NET
- COM — бинарный кроссязыковый инструмент взаимодействия от Microsoft
- P/Invoke — встроенный в платформу механизм для вызова чужих функций

На самом деле есть и более экзотичные способы — можно, например, руками
нагенерировать машинного кода, пометить страничку с ним как выполняемую и
передать туда управление, но такие вещи мы в докладе рассматривать не будем :)

Основной упор в докладе я сделаю на последнем пункте, но для начала давайте
кратко рассмотрим все остальные.

---

- C++/CLI
- COM
- P/Invoke

## C++/CLI

Начнём с C++/CLI. Это такой язык, который основан на стандартном C++, но в него,
во-первых, добавили возможности для интеропа с системой типов .NET. Это
управляемые указатели (которые, по сути, соответствуют нашим ссылкам из C#):

```cpp
System::String ^foo = gcnew System::String("foobaz");
```

Также есть tracking references — это аналог наших `ref`:

```cpp
int x = 10;
int %ref = x;
if (System::Int32::TryParse("42", ref))
    System::Console::WriteLine(x);
```

(этот пример немножко бессмысленный, но я просто хотел показать кусочек
синтаксиса с объявлением tracking reference)

В этом языке отличается managed- и unmanaged-код: есть специальные прагмы,
которыми мы размечаем свою программу, указывая секции с управляемым и нативным
кодом. Типы у управляемого кода свои, для их объявления есть отдельные
синтаксические конструкции. Темплейты работают как для нативного, так и для
управляемого кода, при этом темплейты отличаются от генериков.

При этом нативный код реально компилируется в x86 или x86-64 машинный код,
который складывается в специальные места в нашей управляемой сборке.

Ввиду своего происхождения язык обладает некоторыми очевидными достоинствами:

- **простое потребление заголовочных файлов и API на C и C++**: если у вас уже
  есть заголовочные файлы от какой-то нативной библиотеки, то вы просто берёте
  их, инклудите в программу на C++/CLI, выставляете managed-интерфейс — и дело в
  шляпе
- **возможность использования управляемого и неуправляемого кода в одном
  модуле**, то есть можно при желании тут же написать кусочки логики или
  маппинга между управляемыми и неуправляемыми типами
- **ассемблерные вставки на x86**: компилятор от MS поддерживает ассемблерные
  вставки — впрочем, только на x86. Но, по моему опыту, если вам это всё вообще
  потребовалось на Windows, то скорее всего у вас есть какие-то либы от вендора,
  и они скорее всего как раз x86. Так что можно сказать, что вам повезло — ну
  или не повезло :)

Недостатки:

- **не кроссплатформенно**, что, на мой взгляд, убивает эту интересную
  технологию на корню. На сегодняшний день нет планов по её поддержке ни в .NET
  Core, ни в Mono.

Причём я не шучу про ассемблерные вставки. У нас в продакшене однажды имела
место именно такая ситуация: был внешний API для какой-то железки или иной
системы, который был реализован на Delphi. У этого API было несколько функций,
которые в качестве аргументов принимали колбэки. Мы обычно можем в качестве
колбэков передавать наши managed-делегаты (как это работает — мы ещё обсудим
чуть позже). Только вот Delphi-программисты в объявлении одного из колбэков
забыли поставить спецификатор `stdcall`, и поэтому у него была дефолтовая для
Delphi конвенция вызова — которая, разумеется, в 2015 году уже никем официально
не поддерживалась, и нашим стандартным .NET-интеропом тоже. Одним из решений
этой проблемы было написание кода на C++/CLI, который с помощью ассемблерной
вставки реализует эту экзотическую конвенцию.

Готовясь к докладу, я даже для смеха воспроизвёл этот случай:

```delphi
type
 TMyCallback = function(number: Integer): Integer;

function DoCall(callback: TMyCallback): Integer; cdecl;
begin
  Result := callback(10);
end;
```

```cpp
// Func<int, int> ^functor
auto exportFunction = gcnew ExportFunction(functor, &Func<int, int>::Invoke);
auto ptr = Marshal::GetFunctionPointerForDelegate(safe_cast<Delegate^>(exportFunction));

prepare_call(static_cast<Callback*>(ptr.ToPointer()));
int result = doCallFunction(&perform_wrapped_call);
GC::KeepAlive(exportFunction);
```

```cpp
Callback *CallbackInstance;
void prepare_call(Callback *arg) { CallbackInstance = arg; }

void clear_call() {
  CallbackInstance = nullptr;
}

int __fastcall perform_wrapped_call() {
  int real_argument;
  __asm { mov real_argument, eax }
  return CallbackInstance(real_argument);
}
```

## COM

Стандартный кроссязыковой способ интеропа в Windows, не работает на остальных
платформах (хотя энтузиасты поддерживают несколько реализаций под другие
платформы).

Обычно COM-библиотеки глобально регистрируются в системе, и после этого
референсы на них начинают работать во всех managed-проектах. Из TLB добывается
метаинформация, на основании которой делается managed-интерфейс для работы с
библиотечными типами.

Недостатки этой технологии: не кроссплатформенно, и плохо работает, если в
системе не установлены нужные типы — например, на билд-сервере собрать код,
который работает с COM, бывает сложновато, если вы не контролируете состояние
среды билд-сервера.

Не все знают, что со многими COM-объектами можно работать и без использования
TLB, через `IDispatch` — например, таким образом можно работать с MS Office (а
больше половины всех случаев, когда приходилось использовать COM, на моей памяти
относятся именно к MS Office).

Поэтому в итоге в одном из случаев мне довелось поддерживать смешанное решение:
на тех машинах, на которых установлена COM-библиотека, мы использовали строгую
типизацию и работали через TLB, а на других машинах (у сторонних разработчиков)
использовали `dynamic`. Это даже не очень сложно реализовать через условную
компиляцию. Предположим, что у нас есть такой код:

```csharp
IComService instance = new IComService();
instance.HelloWorld();
```

Для того, чтобы он умел также собираться с использованием `dynamic`, нужно
узнать GUID нужного нам типа, и написать что-то вроде такого:

```csharp
#if COM_LIBRARY_INSTALLED
  IComService instance = new IComService();
#else
  const string TypeGuid = "03653ea3-b63b-447b-9d26-fa86e679087b";
  Type type = Type.GetTypeFromCLSID(Guid.Parse(TypeGuid));
  dynamic instance = Activator.CreateInstance(type);
#endif

  instance.HelloWorld();
```

## P/Invoke

Ну и, наконец, перейдём к интересной части: про P/Invoke. Это мой любимый способ
взаимодействия с нативным кодом, потому что, во-первых, он достаточно гибок, но
не заставляет переписывать весь интеграционный слой на другом языке, а
во-вторых, он работает на всех платформах.

Работа с P/Invoke начинается, конечно, с атрибута `DllImport`. Давайте посмотрим
на его свойства:

```csharp
public sealed class DllImportAttribute : Attribute
{
    public DllImportAttribute(string dllName) { /* ... */ }
    public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool PreserveSig;
    public bool ThrowOnUnmappableChar;
}
```

- в конструктор этот атрибут принимает название библиотеки, из которой будут
  вызываться функции: под Windows и macOS это полное имя файла, а под Linux и
  .NET Core это только имя библиотеки без префикса и постфикса

  ```csharp
  [DllImport("tdjson.dll")] // → tdjson.dll   // Windows
  [DllImport("tdjson")]     // → libtdjson.so // Linux, .NET Core
  [DllImport("libtdjson.so")]  // → libtdjson.so // Linux, Mono
  [DllImport("libtdjson.dylib")] // → libtdjson.dylib // macOS

  [DllImport("__Internal")] // Mono only
  [DllImport("somelib.dll", EntryPoint = "#123")] // by ordinal, Windows
  ```

  Помимо этого, Mono также умеет загружать символы прямо из текущего файла (для
  чего он, конечно, должен быть скомпилирован в нативный код) — это эдакий
  аналог динамического связывания из C++/CLI.
- `EntryPoint` — это имя функции, которая будет вызвана из библиотеки. Если вы
  хотите импортировать функцию по ординалу (бывает такая надобность) — можно
  использовать имена типа `#123`.
- `CharSet`: `Auto` / `Ansi` / `Unicode` (по умолчанию в CLI `Auto`, но в C# –
  `Ansi`)
- `SetLastError` — нужно выставлять для функций, после которых вызывателю
  хочется вызвать `Marshal.GetLastWin32Error`; это нужно для случаев, когда сама
  CLR могла бы затереть последнюю ошибку своими вызовами.
- `ExactSpelling` нужен для того, чтобы CLR могла перестать угадывать название
  функции (`A` или `W`-варианты для WinAPI)
- `CallingConvention` — это нативная конвенция вызова
- `PreserveSig` влияет на интерпретацию возвращаемых значений типа `HRESULT`:
  если `PreserveSig = true` (по умолчанию), то `HRESULT` будет возвращён как
  есть, а если `false` — то невалидный `HRESULT` будет выброшен как исключение.
- `ThrowOnUnmappableChar` — нужен для случаев, когда мы пытаемся скормить
  ANSI-функции юникод, который нормально не представляется в ANSI

### Передача аргументов во внешние функции

Мы разобрались с тем, как рантайм находит функции во внешних библиотеках. Теперь
поговорим о том, как в эти функции мы передаём аргументы. Как известно, нативный
код умеет принимать данные по значению или по указателю.

Для того, чтобы передать значение, мы просто передаём структуру, как мы привыкли
в .NET. Примитивные типы, как и другие структуры, тоже передаются по значению.

- примитивные типы (`int`, `long`, `double` etc.)
- другие value types (структуры, enums)

А вот если мы хотим что-то передать по указателю, то ситуация становится
интереснее. Наши ссылочные типы передаются в нативный код по указателю, а кроме
них // TODO

- ссылочные типы (классы, делегаты)
- unsafe-указатели
- что угодно через `ref` или `out`
- `IntPtr`

- https://docs.microsoft.com/en-us/dotnet/framework/interop/copying-and-pinning
- как маршаллятся blittable и non-blittable

### Размещение структур в памяти

- разные варианты `StructLayoutKind`
- немного про `Pack`
- fixed-массивы
- blittable-типы (aka `unsafe`)
- выравнивание
- совет: не стесняйтесь писать тесты на layout структур, это может пригодиться

#### Строки

- как маршаллить строки и отстрелить себе всё ниже пояса
- виды строк (`string` vs `StringBuilder` в контексте маршаллинга)
- https://fornever.me/ru/posts/2017-09-20-clr-string-marshalling.html
- сравнение производительности при маршаллинге ANSI и Unicode _(юникод должен
  зарулить, потому что будет маршаллиться по указателю)_

### SafeHandle

### ICustomMarshaler: маршаллим что попало как попало

### Пара слов про вызов делегатов из нативного кода

- как маршаллить
- как работает под капотом
- чего опасаться (GC, GC.KeepAlive)

## Немножко IL-кода

- Unmanaged export: https://github.com/ForNeVeR/SpySharp/blob/54c4d2c51a799d7e151a9db332dbe00a8e5bdb2f/SpySharp.Hooker/Hooker.il
- vararg-функции: https://github.com/ForNeVeR/expert-cil-samples/blob/c80436e8dcc9763922c416625765de3b57b5296a/Simple.il#L52

## Распространение нативного кода для .NET Core через NuGet

- layout пакетов с нативным кодом
- `dotnet publish`

## Выводы

- не нужно бояться нативного кода
- по возможности стоит описывать код в безопасном стиле, не пользуясь
  указателями, если можете их избежать — запутаться в таком коде немного сложнее
- `StructLayout` — наш друг
- со строками следует обращаться крайне осторожно и внимательно следить за
  mutable/ref строками и буферами
- не забывайте сохранять ссылки на делегаты, которые должны жить в нативном
  коде, или `GC.KeepAlive`
- всегда обязательно писать подробные тесты на любой код с интеропом, потому что
  этот код очень хрупкий, а диагностировать ошибки в нём очень сложно
- иногда тесты на memory layout — тоже неглупая затея!
